import { FileTree } from 'nextra/components'
import { Callout } from 'nextra/components'
import Tag from '../../../component/Tag'

# Script Bundle Module

A Script Bundle Module is a self-contained ZIP archive that provides all the logic required to expose a **Script Data Source** to Kubling.

A module defines:
- How SQL operations are translated into executable logic
- How external systems or APIs are invoked
- How results and side effects are communicated back to the engine

This page documents the **recommended module structure** and the **execution models supported by the engine**.

## Recommended Module Structure

The following tree illustrates a representative Script Bundle Module, based on a real integration with the JIRA API:

<FileTree>
  <FileTree.File name="bundle-script-info.yaml" />
  <FileTree.File name="jira.ddl" />
  <FileTree.File name="init.js" />

  <FileTree.Folder name="handlers">
    <FileTree.File name="ISSUE.js" />
    <FileTree.File name="PROJECT.js" />
  </FileTree.Folder>

  <FileTree.Folder name="module">
    <FileTree.Folder name="platform">
      <FileTree.Folder name="jira">
        <FileTree.Folder name="api">
          <FileTree.File name="UsersApi.js" />
        </FileTree.Folder>
        <FileTree.Folder name="model">
          <FileTree.File name="Board.js" />
          <FileTree.File name="Commit.js" />
          <FileTree.File name="Component.js" />
        </FileTree.Folder>
        <FileTree.File name="ApiClient.js" />
      </FileTree.Folder>
    </FileTree.Folder>
    <FileTree.Folder name="utils">
      <FileTree.File name="Utils.js" />
    </FileTree.Folder>
  </FileTree.Folder>

  <FileTree.Folder name="scheduled">
    <FileTree.File name="publish_status_to_slack.js" />
  </FileTree.Folder>
</FileTree>

Only one file is strictly required to be located at the root of the module:

- **`bundle-script-info.yaml`**

All other paths follow conventions rather than hard constraints and may be adapted to the moduleâ€™s needs.

## ðŸ“„ `bundle-script-info.yaml`

This file defines the module metadata and how it is wired into the engine.

Among other settings, it controls:
- Which execution model is used
- How scripts are discovered
- How initialization and scheduled logic are registered

See the full schema here:  
[Script Module Bundle Information File](/schemas#script-module-bundle-information-file-bundle-script-infoyaml)

## Table Handlers <Tag description={"v26.1+"} />

Table handlers define a **table-centric execution model** for Script Data Sources.

In this model, the engine resolves handlers dynamically based on table names and invokes operation-specific functions on demand. 
The association between SQL operations and script logic is expressed structurally, rather than through explicit delegate wiring.

Under the table handler model:

- Each table is associated with a single JavaScript file
- The file name determines which table it handles
- SQL operations targeting that table are routed to functions defined in the file

Handlers do not return values.  
They interact with the engine exclusively through **exchange objects** provided at invocation time.

<Callout>
A concrete example of the table handler model can be found in the [kubling-operaton repository](https://github.com/kubling-community/kubling-operaton/tree/main/vdb/orders/mod-apis)
</Callout>


### Handler Resolution

Handlers are discovered under a configured directory inside the module.

For each JavaScript file found:
- The file name is mapped to a table name
- The engine invokes functions on demand when operations target that table

Example layout:

```
handlers/
  ISSUE.js
  PROJECT.js
```

In this case, operations on tables `ISSUE` and `PROJECT` are routed to the corresponding files.

### Handler Contract

A handler file may export any of the following functions (all lowercase):

- `select`
- `insert`
- `update`
- `delete`

Each function receives a **single argument object** composed of two distinct parts:

- Informational input provided by the engine
- Exchange objects used to communicate results back to the engine

The contract is:

```js
// SELECT
select({ queryFilter, resultSet })

// INSERT
insert({ insertOp, affectedRows })

// UPDATE
update({ updateOp, affectedRows })

// DELETE
delete({ deleteOp, affectedRows })
```

### Informational Inputs

Informational inputs describe **what operation the engine is requesting**:

- [`queryFilter`](/engine/script-context-members#queryfilter)
- [`insertOp`](/engine/script-context-members#insertoperation)
- [`updateOp`](/engine/script-context-members#updateoperation)
- [`deleteOp`](/engine/script-context-members#deleteoperation)

These objects are provided by the engine and are treated as read-only by the handler.

### Exchange Objects

Exchange objects represent the **communication channel back to the engine**:

- [`resultSet`](/engine/script-context-members#resultset) is used to emit rows for SELECT operations
- [`affectedRows`](/engine/script-context-members#affectedrows) is used to report affected row counts and generated keys

After handler execution, the engine inspects these objects to determine the outcome of the operation.

### Execution Characteristics

The table handler model:

- Makes table-level behavior explicit and localized
- Eliminates explicit delegate wiring
- Preserves a clear separation between intent (input) and effect (exchange)
- Keeps execution deterministic from the engineâ€™s perspective

## Delegate Scripts

Delegate scripts represent an alternative execution model for Script Data Sources.

In this model, the engine invokes explicitly configured scripts for each operation type:

- ResultSet delegate
- Insert delegate
- Update delegate
- Delete delegate

Delegate-based wiring remains supported to preserve compatibility with existing modules.  
However, new modules are encouraged to adopt the table handler model, as it results in simpler wiring and clearer execution semantics.

## ðŸ“„ Initialization Scripts

Initialization scripts allow a module to perform one-time setup logic required for correct operation.

Typical use cases include:
- Authenticating with external systems
- Fetching or refreshing credentials
- Initializing shared state

If an initialization script is present, it **must report its outcome to the engine**.  
A failure during initialization prevents the engine from starting.

The engine receives this information through the `initResult` context member:  
[initResult context member](/Engine/script-context-members#initresult)

Example:

```js
import { generateAzureToken } from "../api/TokenGenerator";

try {
    generateAzureToken();
    initResult.initialized();
} catch (e) {
    initResult.error(e.message);
}
```

---

## ðŸ“„ Scheduled Scripts

Scheduled scripts are executed periodically based on a cron expression.

They are typically used for:
- Refreshing credentials
- Publishing state to external systems
- Periodic reconciliation or notifications

Scheduled scripts should be used judiciously, as they consume engine resources.

<Callout type="info">
Try to keep scheduled scripts as isolated from the rest of the module logic as possible.
</Callout>

In more advanced setups, scheduled scripts often interact with other systems **through Data Sources**, rather than calling external APIs directly.

<Callout type="info">
In complex scenarios, systems such as Slack are commonly modeled as Data Sources.  
A scheduled script would then perform an INSERT into a table, triggering the actual external interaction through the engine.
</Callout>
